import asyncio
import os
import logging
import time
from typing import List, Optional, Tuple, Dict, Any
from datetime import datetime
from dataclasses import dataclass

from telethon import TelegramClient
from telethon.errors import RPCError
from telegram import Update, BotCommand, Message
from telegram.ext import Application, MessageHandler, filters, ContextTypes

from .monitor import DownloadMonitor
from .downloader import MediaDownloader
from .folder_navigator import FolderNavigator

# Configure logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# Reduce third-party library verbose logging
logging.getLogger('httpx').setLevel(logging.WARNING)
logging.getLogger('telethon.client.updates').setLevel(logging.WARNING)


@dataclass
class ForwardInfo:
    """Data class for forward message information"""
    chat_id: Optional[int]
    message_id: Optional[int]
    chat_name: Optional[str]


@dataclass
class MediaCounts:
    """Data class for media type counts"""
    video: int = 0
    photo: int = 0
    document: int = 0


class MediaGroupHandler:
    """Handles media group collection and processing"""
    
    def __init__(self):
        self.media_groups: Dict[str, List[Message]] = {}
        self.group_timers: Dict[str, asyncio.Task] = {}
    
    def add_message_and_set_timer(self, media_group_id: str, message: Message, callback, delay: float = 2.0) -> None:
        """Add message to group and set/reset timer in one operation"""
        # Add to group
        if media_group_id not in self.media_groups:
            self.media_groups[media_group_id] = []
        self.media_groups[media_group_id].append(message)
        
        # Cancel existing timer and set new one
        if media_group_id in self.group_timers:
            self.group_timers[media_group_id].cancel()
        
        self.group_timers[media_group_id] = asyncio.create_task(
            self._process_delayed(media_group_id, callback, delay)
        )
        
        logger.info(f"Media group {media_group_id} now has {len(self.media_groups[media_group_id])} messages")
    
    async def _process_delayed(self, media_group_id: str, callback, delay: float) -> None:
        """Process media group after delay"""
        await asyncio.sleep(delay)
        
        if media_group_id in self.media_groups:
            messages = self.media_groups[media_group_id]
            logger.info(f"Processing media group {media_group_id} with {len(messages)} messages")
            
            if messages:
                await callback(messages[0], messages)
            
            # Cleanup
            self.media_groups.pop(media_group_id, None)
            self.group_timers.pop(media_group_id, None)


class MessageProcessor:
    """Handles message processing logic"""
    
    def __init__(self, client: TelegramClient):
        self.client = client
    
    async def get_message_with_replies(self, chat_id: int, message_id: int) -> Tuple[Optional[Any], List[Any]]:
        """Get message and its replies with error handling"""
        try:
            logger.info(f"Fetching message chat_id={chat_id}, message_id={message_id}")
            
            # Get chat entity and original message
            chat = await self.client.get_entity(chat_id)
            original_message = await self.client.get_messages(chat, ids=message_id)
            
            if not original_message:
                logger.warning(f"Message ID {message_id} not found")
                return None, []
            
            # Get replies
            replies = []
            try:
                async for reply in self.client.iter_messages(chat, reply_to=message_id):
                    replies.append(reply)
            except Exception as e:
                logger.warning(f"Error getting replies: {e}")
            
            logger.info(f"Found original message and {len(replies)} replies")
            return original_message, replies
            
        except Exception as e:
            logger.error(f"Error getting message: {e}")
            return None, []
    
    def extract_forward_info(self, message: Message) -> ForwardInfo:
        """Extract forward message information"""
        from telegram import MessageOriginChannel, MessageOriginChat
        
        origin = message.forward_origin
        if isinstance(origin, MessageOriginChannel):
            return ForwardInfo(
                chat_id=origin.chat.id,
                message_id=origin.message_id,
                chat_name=origin.chat.title or origin.chat.username
            )
        elif isinstance(origin, MessageOriginChat):
            return ForwardInfo(
                chat_id=origin.sender_chat.id,
                message_id=origin.message_id,
                chat_name=origin.sender_chat.title or origin.sender_chat.username
            )
        else:
            return ForwardInfo(None, None, None)
    
    async def extract_all_media_files(self, original_message, replies: List[Any], 
                                    chat_id: int, is_group: bool) -> List[Any]:
        """Extract all media files from message and replies"""
        messages_to_download = []
        
        # Add original message if it has media
        if original_message.media:
            messages_to_download.append(original_message)
        
        # Handle media group
        if is_group and hasattr(original_message, 'grouped_id') and original_message.grouped_id:
            try:
                telethon_group_id = original_message.grouped_id
                async for msg in self.client.iter_messages(chat_id, limit=100):
                    if (hasattr(msg, 'grouped_id') and 
                        msg.grouped_id == telethon_group_id and 
                        msg.media and 
                        msg.id != original_message.id):
                        messages_to_download.append(msg)
                logger.info(f"Found {len(messages_to_download)} media files in group")
            except Exception as e:
                logger.warning(f"Cannot get media group files: {e}")
        
        # Add media from replies
        for reply in replies:
            if reply.media:
                messages_to_download.append(reply)
        
        return messages_to_download
    
    def count_media_types(self, messages: List[Any]) -> MediaCounts:
        """Count media types in messages"""
        counts = MediaCounts()
        
        for msg in messages:
            if msg.video or (hasattr(msg, 'document') and msg.document and 
                           msg.document.mime_type and msg.document.mime_type.startswith('video/')):
                counts.video += 1
            elif msg.photo:
                counts.photo += 1
            elif hasattr(msg, 'document') and msg.document:
                counts.document += 1
        
        return counts


class TelegramMediaBot:
    """Main Telegram Media Download Bot class"""
    
    def __init__(self, api_id: int, api_hash: str, phone_number: str, bot_token: str):
        self.phone_number = phone_number
        self.bot_token = bot_token
        
        # Initialize Telegram client
        self.client = TelegramClient(
            'bot_session', api_id, api_hash,
            connection_retries=3, retry_delay=1, auto_reconnect=True, timeout=30
        )
        
        # Initialize bot application
        self.app = Application.builder().token(bot_token).build()
        self.app.add_handler(MessageHandler(filters.ALL, self.handle_message))
        
        # Initialize components
        self.loop = asyncio.get_event_loop()
        self.monitor = DownloadMonitor(self.loop)
        
        db_path = os.path.join(os.path.dirname(os.path.dirname(__file__)), "downloads.db")
        self.downloader = MediaDownloader(self.client, max_concurrent_downloads=5, db_path=db_path)
        self.downloader.set_monitor(self.monitor)
        
        downloads_path = os.path.join(os.path.dirname(os.path.dirname(__file__)), "downloads")
        self.folder_navigator = FolderNavigator(downloads_path)
        
        # Handlers
        self.media_group_handler = MediaGroupHandler()
        self.message_processor = MessageProcessor(self.client)
    
    async def handle_message(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """Main message handler"""
        message = update.message
        user_id = message.from_user.id
        
        # Handle commands
        if await self._handle_commands(message, user_id):
            return
        
        # Check if message is downloadable
        if not self._is_downloadable_message(message):
            await self._send_usage_instruction(message)
            return
        
        # Handle media group or single message
        if message.media_group_id:
            self.media_group_handler.add_message_and_set_timer(
                message.media_group_id, message, self._process_message
            )
        else:
            await self._process_message(message)
    
    async def _handle_commands(self, message: Message, user_id: int) -> bool:
        """Handle bot commands, return True if handled"""
        text = message.text
        
        if text == "/help":
            help_text = (
                "ä½¿ç”¨è³‡æ–™å¤¾å‘½ä»¤é¸æ“‡å­˜æ”¾ä½ç½®ï¼š\n"
                "/cr, /å‰µå»º è³‡æ–™å¤¾å - å‰µå»ºè³‡æ–™å¤¾\n"
                "/cd, /é€²å…¥ è³‡æ–™å¤¾å - é€²å…¥è³‡æ–™å¤¾\n"
                "/cd.., /é€€å‡º - è¿”å›žä¸Šç´š\n"
                "/ok, /ç¢ºå®š - ç¢ºèªä½ç½®"
            )
            await message.reply_text(help_text)
            return True
        
        # Handle folder navigation commands
        if text and self.folder_navigator.is_folder_command(text):
            response, is_confirmed = self.folder_navigator.process_folder_command(user_id, text)
            await message.reply_text(response)
            
            if is_confirmed:
                await asyncio.sleep(2)
                await self._start_download_process(user_id, message)
            return True
        
        # Check if user is in folder selection mode
        if self.folder_navigator.is_awaiting_folder_selection(user_id):
            await message.reply_text(
                "è«‹ä½¿ç”¨è³‡æ–™å¤¾å‘½ä»¤é¸æ“‡å­˜æ”¾ä½ç½®ï¼š\n"
                "/cr, /å‰µå»º è³‡æ–™å¤¾å - å‰µå»ºè³‡æ–™å¤¾\n"
                "/cd, /é€²å…¥ è³‡æ–™å¤¾å - é€²å…¥è³‡æ–™å¤¾\n"
                "/cd.., /é€€å‡º - è¿”å›žä¸Šç´š\n"
                "/ok, /ç¢ºå®š - ç¢ºèªä½ç½®"
            )
            return True
        
        return False
    
    def _is_downloadable_message(self, message: Message) -> bool:
        """Check if message is downloadable"""
        if not message.forward_origin:
            return False
        
        # Check if from private chat or hidden user
        from telegram import MessageOriginChannel, MessageOriginChat
        return isinstance(message.forward_origin, (MessageOriginChannel, MessageOriginChat))
    
    async def _send_usage_instruction(self, message: Message) -> None:
        """Send usage instruction or error message"""
        if not message.forward_origin:
            instruction = (
                "è«‹è½‰ç™¼ä¸€å‰‡è¨Šæ¯çµ¦æˆ‘ï¼Œæˆ‘æœƒå‚™ä»½è©²è¨Šæ¯åŠå…¶æ‰€æœ‰å›žè¦†ä¸­çš„åª’é«”æ–‡ä»¶åˆ°ä¼ºæœå™¨ï¼\n\n"
                "æ”¯æ´çš„åª’é«”é¡žåž‹ï¼šç…§ç‰‡ã€å½±ç‰‡ã€GIFã€éŸ³è¨Šç­‰"
            )
        else:
            instruction = "âŒ æš«ä¸æ”¯æ´ä¾†è‡ªç§äººèŠå¤©æˆ–éš±è—ç”¨æˆ¶çš„è½‰ç™¼è¨Šæ¯"
        
        await message.reply_text(instruction)
    
    async def _process_message(self, message: Message, group_messages: Optional[List[Message]] = None) -> None:
        """Process a single message or media group"""
        user_id = message.from_user.id
        is_group = group_messages is not None
        
        processing_msg = await message.reply_text(
            f"ðŸ“¡ æ­£åœ¨ç²å–ä¾†è‡ª{'åª’é«”çµ„' if is_group else ''}çš„è¨Šæ¯..."
        )
        
        try:
            # Extract forward info
            forward_info = self.message_processor.extract_forward_info(message)
            if not forward_info.chat_id:
                await processing_msg.edit_text("âŒ æš«ä¸æ”¯æ´ä¾†è‡ªç§äººèŠå¤©æˆ–éš±è—ç”¨æˆ¶çš„è½‰ç™¼è¨Šæ¯")
                return
            
            await processing_msg.edit_text(f"ðŸ“¡ æ­£åœ¨ç²å–ä¾†è‡ª {forward_info.chat_name} çš„è¨Šæ¯...")
            
            # Get original message and replies
            original_message, replies = await self.message_processor.get_message_with_replies(
                forward_info.chat_id, forward_info.message_id
            )
            
            if not original_message:
                await processing_msg.edit_text(
                    "âŒ ç„¡æ³•ç²å–åŽŸè¨Šæ¯\n\n"
                    "å¯èƒ½çš„åŽŸå› ï¼š\n"
                    "â€¢ Bot æ²’æœ‰æ¬Šé™è¨ªå•è©²é »é“/ç¾¤çµ„\n"
                    "â€¢ è¨Šæ¯å·²è¢«åˆªé™¤\n"
                    "â€¢ è¨Šæ¯ ID ç„¡æ•ˆ\n\n"
                    "è«‹ç¢ºèª Bot æ˜¯è©²é »é“/ç¾¤çµ„çš„æˆå“¡"
                )
                return
            
            # Extract all media files
            messages_to_download = await self.message_processor.extract_all_media_files(
                original_message, replies, forward_info.chat_id, is_group
            )
            
            if not messages_to_download:
                await processing_msg.edit_text("â„¹ï¸ è©²è¨Šæ¯åŠå…¶å›žè¦†ä¸­æ²’æœ‰æ‰¾åˆ°ä»»ä½•åª’é«”æ–‡ä»¶")
                return
            
            # Count media types and start folder selection
            media_counts = self.message_processor.count_media_types(messages_to_download)
            folder_ui = self.folder_navigator.start_folder_selection(
                user_id, group_messages or [message], media_counts.__dict__
            )
            await processing_msg.edit_text(folder_ui)
            
        except Exception as e:
            logger.error(f"Error processing message: {e}")
            await processing_msg.edit_text(f"âŒ è™•ç†æ™‚å‡ºéŒ¯: {str(e)}")
    
    async def _start_download_process(self, user_id: int, message: Message) -> None:
        """Start download process for confirmed folder selection"""
        try:
            pending_messages = self.folder_navigator.get_pending_messages(user_id)
            if not pending_messages:
                await message.reply_text("âŒ æ²’æœ‰æ‰¾åˆ°å¾…è™•ç†çš„æ¶ˆæ¯")
                return
            
            selected_path = self.folder_navigator.get_selected_path(user_id)
            processing_msg = await message.reply_text("âœˆï¸ é–‹å§‹ä¸‹è¼‰æµç¨‹...")
            
            await self._execute_download(processing_msg, pending_messages, selected_path)
            self.folder_navigator.clear_user_state(user_id)
            
        except Exception as e:
            logger.error(f"Error starting download process: {e}")
            await message.reply_text(f"âŒ é–‹å§‹ä¸‹è¼‰æ™‚å‡ºéŒ¯: {str(e)}")
    
    async def _execute_download(self, processing_msg: Message, pending_messages: List[Message], selected_path: str) -> None:
        """Execute the download process"""
        try:
            first_message = pending_messages[0]
            
            # Extract source info
            forward_info = self.message_processor.extract_forward_info(first_message)
            if not forward_info.chat_id:
                await processing_msg.edit_text("âŒ ç„¡æ³•è™•ç†æ­¤é¡žåž‹çš„è½‰ç™¼è¨Šæ¯")
                return
            
            # Get original message and replies
            original_message, replies = await self.message_processor.get_message_with_replies(
                forward_info.chat_id, forward_info.message_id
            )
            
            if not original_message:
                await processing_msg.edit_text("âŒ ç„¡æ³•è¨ªå•åŽŸå§‹è¨Šæ¯")
                return
            
            # Extract all files for download
            is_group = len(pending_messages) > 1
            messages_to_download = await self.message_processor.extract_all_media_files(
                original_message, replies, forward_info.chat_id, is_group
            )
            
            if not messages_to_download:
                await processing_msg.edit_text("â„¹ï¸ è©²è¨Šæ¯åŠå…¶å›žè¦†ä¸­æ²’æœ‰æ‰¾åˆ°ä»»ä½•åª’é«”æ–‡ä»¶")
                return
            
            # Create download directory and start download
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            dir_prefix = "mediagroup" if is_group else "message"
            download_dir = os.path.join(selected_path, f"{dir_prefix}_{forward_info.message_id}_{timestamp}")
            
            await self._download_with_monitoring(
                processing_msg, messages_to_download, download_dir, 
                forward_info.message_id, forward_info.chat_name
            )
            
        except Exception as e:
            logger.error(f"Error executing download: {e}")
            await processing_msg.edit_text(f"âŒ è™•ç†æ™‚å‡ºéŒ¯: {str(e)}")
    
    async def _download_with_monitoring(self, processing_msg: Message, messages_to_download: List[Any], 
                                      download_dir: str, original_message_id: int, chat_name: str) -> None:
        """Handle download with monitoring and result reporting"""
        # Initialize monitoring
        self.monitor.update_stats({
            'total_files': 0, 'completed_files': 0, 'failed_files': 0,
            'total_size': 0, 'downloaded_size': 0, 'start_time': time.time()
        })
        self.monitor.start_monitoring_thread(download_dir, processing_msg)
        
        try:
            await processing_msg.edit_text("ðŸ“Š æ­£åœ¨åˆ†æžåª’é«”æ–‡ä»¶...")
            
            # Calculate total size
            total_size = 0
            for message in messages_to_download:
                if message.media:
                    total_size += await self.downloader.get_media_size(message)
            
            await processing_msg.edit_text(
                f"ðŸš€ é–‹å§‹ä¸‹è¼‰ {len(messages_to_download)} å€‹åª’é«”æ–‡ä»¶ï¼Œ"
                f"ç¸½å¤§å°: {total_size/(1024**2):.1f}MB..."
            )
            
            # Execute download
            await self.downloader.download_multiple_messages_concurrent(messages_to_download, download_dir)
            
        finally:
            self.monitor.stop_monitoring()
            await asyncio.sleep(0.5)
        
        # Send results
        await self._send_download_results(processing_msg, download_dir, original_message_id, chat_name)
    
    async def _send_download_results(self, processing_msg: Message, download_dir: str, 
                                   original_message_id: int, chat_name: str) -> None:
        """Send final download results"""
        stats = self.monitor.get_stats()
        elapsed_time = time.time() - stats['start_time']
        avg_speed = (stats['downloaded_size'] / (1024**2)) / max(elapsed_time, 1)
        disk_usage = self.monitor.get_disk_usage(download_dir)
        
        # Format result message
        result_msg = f"âœ… ä¸‹è¼‰å®Œæˆï¼\n"
        result_msg += f"åŽŸè¨Šæ¯ ID: {original_message_id}\n"
        result_msg += f"ä¾†æº: {chat_name}\n"
        result_msg += f"æˆåŠŸä¸‹è¼‰: {stats['completed_files']} å€‹åª’é«”æ–‡ä»¶\n"
        
        if stats['failed_files'] > 0:
            result_msg += f"å¤±æ•—: {stats['failed_files']} å€‹æ–‡ä»¶\n"
        
        if stats['total_size'] > 0:
            completion_rate = (stats['downloaded_size'] / stats['total_size']) * 100
            result_msg += (f"ä¸‹è¼‰å¤§å°: {stats['downloaded_size']/(1024**2):.1f}MB / "
                          f"{stats['total_size']/(1024**2):.1f}MB ({completion_rate:.1f}%)\n")
        else:
            result_msg += f"ä¸‹è¼‰å¤§å°: {stats['downloaded_size']/(1024**2):.1f}MB\n"
        
        result_msg += f"å¹³å‡é€Ÿåº¦: {avg_speed:.1f}MB/s\n"
        result_msg += f"è€—æ™‚: {elapsed_time:.1f}ç§’\n"
        result_msg += f"å‰©é¤˜ç©ºé–“: {disk_usage['free_gb']:.1f}GB\n"
        result_msg += f"å„²å­˜ä½ç½®: {download_dir}"
        
        await processing_msg.edit_text(result_msg)
        
        logger.info(f"Download complete - Success: {stats['completed_files']}, "
                   f"Failed: {stats['failed_files']}, Size: {stats['downloaded_size']/(1024**2):.1f}MB, "
                   f"Speed: {avg_speed:.1f}MB/s")
    
    # Public API methods (kept as they might be used externally)
    def get_download_statistics(self) -> Dict[str, Any]:
        """Get download statistics"""
        return self.downloader.get_download_statistics()
    
    def cleanup_missing_files(self) -> Any:
        """Clean up database records pointing to non-existent files"""
        return self.downloader.cleanup_missing_files()
    
    def get_recent_downloads(self, limit: int = 10) -> Any:
        """Get list of recent downloads"""
        return self.downloader.get_recent_downloads(limit)
    
    async def run(self) -> None:
        """Start and run the bot"""
        try:
            # Start Telegram client
            await self.client.start(phone=self.phone_number)
            logger.info("Telegram Client started")
            
            # Start bot
            await self.app.initialize()
            await self.app.start()
            logger.info("Telegram Bot started")
            
            # Set bot commands
            commands = [BotCommand("help", "æŸ¥çœ‹å¹«åŠ©")]
            await self.app.bot.set_my_commands(commands)
            
            logger.info("Bot started! Ready to receive forwarded messages")
            
            # Start polling and keep running
            await self.app.updater.start_polling()
            while True:
                await asyncio.sleep(1)
                
        except Exception as e:
            logger.error(f"Bot runtime error: {e}")
        finally:
            # Cleanup
            await self.app.stop()
            await self.app.shutdown()
            await self.client.disconnect()