import asyncio
import os
import logging
import time
from typing import List, Optional, Tuple, Dict, Any
from datetime import datetime
from dataclasses import dataclass

from telethon import TelegramClient
from telethon.errors import RPCError
from telegram import Update, BotCommand, Message
from telegram.ext import Application, MessageHandler, filters, ContextTypes

from .monitor import DownloadMonitor
from .downloader import MediaDownloader
from .folder_navigator import FolderNavigator

# Configure logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# Reduce third-party library verbose logging
logging.getLogger('httpx').setLevel(logging.WARNING)
logging.getLogger('telethon.client.updates').setLevel(logging.WARNING)


@dataclass
class ForwardInfo:
    """Data class for forward message information"""
    chat_id: Optional[int]
    message_id: Optional[int]
    chat_name: Optional[str]


@dataclass
class MediaCounts:
    """Data class for media type counts"""
    video: int = 0
    photo: int = 0
    document: int = 0


class MediaGroupHandler:
    """Handles media group collection and processing"""
    
    def __init__(self):
        self.media_groups: Dict[str, List[Message]] = {}
        self.group_timers: Dict[str, asyncio.Task] = {}
    
    def add_message_and_set_timer(self, media_group_id: str, message: Message, callback, delay: float = 2.0) -> None:
        """Add message to group and set/reset timer in one operation"""
        # Add to group
        if media_group_id not in self.media_groups:
            self.media_groups[media_group_id] = []
        self.media_groups[media_group_id].append(message)
        
        # Cancel existing timer and set new one
        if media_group_id in self.group_timers:
            self.group_timers[media_group_id].cancel()
        
        self.group_timers[media_group_id] = asyncio.create_task(
            self._process_delayed(media_group_id, callback, delay)
        )
        
        logger.info(f"Media group {media_group_id} now has {len(self.media_groups[media_group_id])} messages")
    
    async def _process_delayed(self, media_group_id: str, callback, delay: float) -> None:
        """Process media group after delay"""
        await asyncio.sleep(delay)
        
        if media_group_id in self.media_groups:
            messages = self.media_groups[media_group_id]
            logger.info(f"Processing media group {media_group_id} with {len(messages)} messages")
            
            if messages:
                await callback(messages[0], messages)
            
            # Cleanup
            self.media_groups.pop(media_group_id, None)
            self.group_timers.pop(media_group_id, None)


class MessageProcessor:
    """Handles message processing logic"""
    
    def __init__(self, client: TelegramClient):
        self.client = client
    
    async def get_message_with_replies(self, chat_id: int, message_id: int) -> Tuple[Optional[Any], List[Any]]:
        """Get message and its replies with error handling"""
        try:
            logger.info(f"Fetching message chat_id={chat_id}, message_id={message_id}")
            
            # Get chat entity and original message
            chat = await self.client.get_entity(chat_id)
            original_message = await self.client.get_messages(chat, ids=message_id)
            
            if not original_message:
                logger.warning(f"Message ID {message_id} not found")
                return None, []
            
            # Get replies
            replies = []
            try:
                async for reply in self.client.iter_messages(chat, reply_to=message_id):
                    replies.append(reply)
            except Exception as e:
                logger.warning(f"Error getting replies: {e}")
            
            logger.info(f"Found original message and {len(replies)} replies")
            return original_message, replies
            
        except Exception as e:
            logger.error(f"Error getting message: {e}")
            return None, []
    
    def extract_forward_info(self, message: Message) -> ForwardInfo:
        """Extract forward message information"""
        from telegram import MessageOriginChannel, MessageOriginChat
        
        origin = message.forward_origin
        if isinstance(origin, MessageOriginChannel):
            return ForwardInfo(
                chat_id=origin.chat.id,
                message_id=origin.message_id,
                chat_name=origin.chat.title or origin.chat.username
            )
        elif isinstance(origin, MessageOriginChat):
            return ForwardInfo(
                chat_id=origin.sender_chat.id,
                message_id=origin.message_id,
                chat_name=origin.sender_chat.title or origin.sender_chat.username
            )
        else:
            return ForwardInfo(None, None, None)
    
    async def extract_all_media_files(self, original_message, replies: List[Any], 
                                    chat_id: int, is_group: bool) -> List[Any]:
        """Extract all media files from message and replies"""
        messages_to_download = []
        
        # Add original message if it has media
        if original_message.media:
            messages_to_download.append(original_message)
        
        # Handle media group
        if is_group and hasattr(original_message, 'grouped_id') and original_message.grouped_id:
            try:
                telethon_group_id = original_message.grouped_id
                async for msg in self.client.iter_messages(chat_id, limit=100):
                    if (hasattr(msg, 'grouped_id') and 
                        msg.grouped_id == telethon_group_id and 
                        msg.media and 
                        msg.id != original_message.id):
                        messages_to_download.append(msg)
                logger.info(f"Found {len(messages_to_download)} media files in group")
            except Exception as e:
                logger.warning(f"Cannot get media group files: {e}")
        
        # Add media from replies
        for reply in replies:
            if reply.media:
                messages_to_download.append(reply)
        
        return messages_to_download
    
    def count_media_types(self, messages: List[Any]) -> MediaCounts:
        """Count media types in messages"""
        counts = MediaCounts()
        
        for msg in messages:
            if msg.video or (hasattr(msg, 'document') and msg.document and 
                           msg.document.mime_type and msg.document.mime_type.startswith('video/')):
                counts.video += 1
            elif msg.photo:
                counts.photo += 1
            elif hasattr(msg, 'document') and msg.document:
                counts.document += 1
        
        return counts


class TelegramMediaBot:
    """Main Telegram Media Download Bot class"""
    
    def __init__(self, api_id: int, api_hash: str, phone_number: str, bot_token: str):
        self.phone_number = phone_number
        self.bot_token = bot_token
        
        # Initialize Telegram client
        self.client = TelegramClient(
            'bot_session', api_id, api_hash,
            connection_retries=3, retry_delay=1, auto_reconnect=True, timeout=30
        )
        
        # Initialize bot application
        self.app = Application.builder().token(bot_token).build()
        self.app.add_handler(MessageHandler(filters.ALL, self.handle_message))
        
        # Initialize components
        self.loop = asyncio.get_event_loop()
        self.monitor = DownloadMonitor(self.loop)
        
        db_path = os.path.join(os.path.dirname(os.path.dirname(__file__)), "downloads.db")
        self.downloader = MediaDownloader(self.client, max_concurrent_downloads=5, db_path=db_path)
        self.downloader.set_monitor(self.monitor)
        
        downloads_path = os.path.join(os.path.dirname(os.path.dirname(__file__)), "downloads")
        self.folder_navigator = FolderNavigator(downloads_path)
        
        # Handlers
        self.media_group_handler = MediaGroupHandler()
        self.message_processor = MessageProcessor(self.client)
    
    async def handle_message(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """Main message handler"""
        message = update.message
        user_id = message.from_user.id
        
        # Handle commands
        if await self._handle_commands(message, user_id):
            return
        
        # Check if message is downloadable
        if not self._is_downloadable_message(message):
            await self._send_usage_instruction(message)
            return
        
        # Handle media group or single message
        if message.media_group_id:
            self.media_group_handler.add_message_and_set_timer(
                message.media_group_id, message, self._process_message
            )
        else:
            await self._process_message(message)
    
    async def _handle_commands(self, message: Message, user_id: int) -> bool:
        """Handle bot commands, return True if handled"""
        text = message.text
        
        if text == "/help":
            help_text = (
                "使用資料夾命令選擇存放位置：\n"
                "/cr, /創建 資料夾名 - 創建資料夾\n"
                "/cd, /進入 資料夾名 - 進入資料夾\n"
                "/cd.., /退出 - 返回上級\n"
                "/ok, /確定 - 確認位置"
            )
            await message.reply_text(help_text)
            return True
        
        # Handle folder navigation commands
        if text and self.folder_navigator.is_folder_command(text):
            response, is_confirmed = self.folder_navigator.process_folder_command(user_id, text)
            await message.reply_text(response)
            
            if is_confirmed:
                await asyncio.sleep(2)
                await self._start_download_process(user_id, message)
            return True
        
        # Check if user is in folder selection mode
        if self.folder_navigator.is_awaiting_folder_selection(user_id):
            await message.reply_text(
                "請使用資料夾命令選擇存放位置：\n"
                "/cr, /創建 資料夾名 - 創建資料夾\n"
                "/cd, /進入 資料夾名 - 進入資料夾\n"
                "/cd.., /退出 - 返回上級\n"
                "/ok, /確定 - 確認位置"
            )
            return True
        
        return False
    
    def _is_downloadable_message(self, message: Message) -> bool:
        """Check if message is downloadable"""
        if not message.forward_origin:
            return False
        
        # Check if from private chat or hidden user
        from telegram import MessageOriginChannel, MessageOriginChat
        return isinstance(message.forward_origin, (MessageOriginChannel, MessageOriginChat))
    
    async def _send_usage_instruction(self, message: Message) -> None:
        """Send usage instruction or error message"""
        if not message.forward_origin:
            instruction = (
                "請轉發一則訊息給我，我會備份該訊息及其所有回覆中的媒體文件到伺服器！\n\n"
                "支援的媒體類型：照片、影片、GIF、音訊等"
            )
        else:
            instruction = "❌ 暫不支援來自私人聊天或隱藏用戶的轉發訊息"
        
        await message.reply_text(instruction)
    
    async def _process_message(self, message: Message, group_messages: Optional[List[Message]] = None) -> None:
        """Process a single message or media group"""
        user_id = message.from_user.id
        is_group = group_messages is not None
        
        processing_msg = await message.reply_text(
            f"📡 正在獲取來自{'媒體組' if is_group else ''}的訊息..."
        )
        
        try:
            # Extract forward info
            forward_info = self.message_processor.extract_forward_info(message)
            if not forward_info.chat_id:
                await processing_msg.edit_text("❌ 暫不支援來自私人聊天或隱藏用戶的轉發訊息")
                return
            
            await processing_msg.edit_text(f"📡 正在獲取來自 {forward_info.chat_name} 的訊息...")
            
            # Get original message and replies
            original_message, replies = await self.message_processor.get_message_with_replies(
                forward_info.chat_id, forward_info.message_id
            )
            
            if not original_message:
                await processing_msg.edit_text(
                    "❌ 無法獲取原訊息\n\n"
                    "可能的原因：\n"
                    "• Bot 沒有權限訪問該頻道/群組\n"
                    "• 訊息已被刪除\n"
                    "• 訊息 ID 無效\n\n"
                    "請確認 Bot 是該頻道/群組的成員"
                )
                return
            
            # Extract all media files
            messages_to_download = await self.message_processor.extract_all_media_files(
                original_message, replies, forward_info.chat_id, is_group
            )
            
            if not messages_to_download:
                await processing_msg.edit_text("ℹ️ 該訊息及其回覆中沒有找到任何媒體文件")
                return
            
            # Count media types and start folder selection
            media_counts = self.message_processor.count_media_types(messages_to_download)
            folder_ui = self.folder_navigator.start_folder_selection(
                user_id, group_messages or [message], media_counts.__dict__
            )
            await processing_msg.edit_text(folder_ui)
            
        except Exception as e:
            logger.error(f"Error processing message: {e}")
            await processing_msg.edit_text(f"❌ 處理時出錯: {str(e)}")
    
    async def _start_download_process(self, user_id: int, message: Message) -> None:
        """Start download process for confirmed folder selection"""
        try:
            pending_messages = self.folder_navigator.get_pending_messages(user_id)
            if not pending_messages:
                await message.reply_text("❌ 沒有找到待處理的消息")
                return
            
            selected_path = self.folder_navigator.get_selected_path(user_id)
            processing_msg = await message.reply_text("✈️ 開始下載流程...")
            
            await self._execute_download(processing_msg, pending_messages, selected_path)
            self.folder_navigator.clear_user_state(user_id)
            
        except Exception as e:
            logger.error(f"Error starting download process: {e}")
            await message.reply_text(f"❌ 開始下載時出錯: {str(e)}")
    
    async def _execute_download(self, processing_msg: Message, pending_messages: List[Message], selected_path: str) -> None:
        """Execute the download process"""
        try:
            first_message = pending_messages[0]
            
            # Extract source info
            forward_info = self.message_processor.extract_forward_info(first_message)
            if not forward_info.chat_id:
                await processing_msg.edit_text("❌ 無法處理此類型的轉發訊息")
                return
            
            # Get original message and replies
            original_message, replies = await self.message_processor.get_message_with_replies(
                forward_info.chat_id, forward_info.message_id
            )
            
            if not original_message:
                await processing_msg.edit_text("❌ 無法訪問原始訊息")
                return
            
            # Extract all files for download
            is_group = len(pending_messages) > 1
            messages_to_download = await self.message_processor.extract_all_media_files(
                original_message, replies, forward_info.chat_id, is_group
            )
            
            if not messages_to_download:
                await processing_msg.edit_text("ℹ️ 該訊息及其回覆中沒有找到任何媒體文件")
                return
            
            # Create download directory and start download
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            dir_prefix = "mediagroup" if is_group else "message"
            download_dir = os.path.join(selected_path, f"{dir_prefix}_{forward_info.message_id}_{timestamp}")
            
            await self._download_with_monitoring(
                processing_msg, messages_to_download, download_dir, 
                forward_info.message_id, forward_info.chat_name
            )
            
        except Exception as e:
            logger.error(f"Error executing download: {e}")
            await processing_msg.edit_text(f"❌ 處理時出錯: {str(e)}")
    
    async def _download_with_monitoring(self, processing_msg: Message, messages_to_download: List[Any], 
                                      download_dir: str, original_message_id: int, chat_name: str) -> None:
        """Handle download with monitoring and result reporting"""
        # Initialize monitoring
        self.monitor.update_stats({
            'total_files': 0, 'completed_files': 0, 'failed_files': 0,
            'total_size': 0, 'downloaded_size': 0, 'start_time': time.time()
        })
        self.monitor.start_monitoring_thread(download_dir, processing_msg)
        
        try:
            await processing_msg.edit_text("📊 正在分析媒體文件...")
            
            # Calculate total size
            total_size = 0
            for message in messages_to_download:
                if message.media:
                    total_size += await self.downloader.get_media_size(message)
            
            await processing_msg.edit_text(
                f"🚀 開始下載 {len(messages_to_download)} 個媒體文件，"
                f"總大小: {total_size/(1024**2):.1f}MB..."
            )
            
            # Execute download
            await self.downloader.download_multiple_messages_concurrent(messages_to_download, download_dir)
            
        finally:
            self.monitor.stop_monitoring()
            await asyncio.sleep(0.5)
        
        # Send results
        await self._send_download_results(processing_msg, download_dir, original_message_id, chat_name)
    
    async def _send_download_results(self, processing_msg: Message, download_dir: str, 
                                   original_message_id: int, chat_name: str) -> None:
        """Send final download results"""
        stats = self.monitor.get_stats()
        elapsed_time = time.time() - stats['start_time']
        avg_speed = (stats['downloaded_size'] / (1024**2)) / max(elapsed_time, 1)
        disk_usage = self.monitor.get_disk_usage(download_dir)
        
        # Format result message
        result_msg = f"✅ 下載完成！\n"
        result_msg += f"原訊息 ID: {original_message_id}\n"
        result_msg += f"來源: {chat_name}\n"
        result_msg += f"成功下載: {stats['completed_files']} 個媒體文件\n"
        
        if stats['failed_files'] > 0:
            result_msg += f"失敗: {stats['failed_files']} 個文件\n"
        
        if stats['total_size'] > 0:
            completion_rate = (stats['downloaded_size'] / stats['total_size']) * 100
            result_msg += (f"下載大小: {stats['downloaded_size']/(1024**2):.1f}MB / "
                          f"{stats['total_size']/(1024**2):.1f}MB ({completion_rate:.1f}%)\n")
        else:
            result_msg += f"下載大小: {stats['downloaded_size']/(1024**2):.1f}MB\n"
        
        result_msg += f"平均速度: {avg_speed:.1f}MB/s\n"
        result_msg += f"耗時: {elapsed_time:.1f}秒\n"
        result_msg += f"剩餘空間: {disk_usage['free_gb']:.1f}GB\n"
        result_msg += f"儲存位置: {download_dir}"
        
        await processing_msg.edit_text(result_msg)
        
        logger.info(f"Download complete - Success: {stats['completed_files']}, "
                   f"Failed: {stats['failed_files']}, Size: {stats['downloaded_size']/(1024**2):.1f}MB, "
                   f"Speed: {avg_speed:.1f}MB/s")
    
    # Public API methods (kept as they might be used externally)
    def get_download_statistics(self) -> Dict[str, Any]:
        """Get download statistics"""
        return self.downloader.get_download_statistics()
    
    def cleanup_missing_files(self) -> Any:
        """Clean up database records pointing to non-existent files"""
        return self.downloader.cleanup_missing_files()
    
    def get_recent_downloads(self, limit: int = 10) -> Any:
        """Get list of recent downloads"""
        return self.downloader.get_recent_downloads(limit)
    
    async def run(self) -> None:
        """Start and run the bot"""
        try:
            # Start Telegram client
            await self.client.start(phone=self.phone_number)
            logger.info("Telegram Client started")
            
            # Start bot
            await self.app.initialize()
            await self.app.start()
            logger.info("Telegram Bot started")
            
            # Set bot commands
            commands = [BotCommand("help", "查看幫助")]
            await self.app.bot.set_my_commands(commands)
            
            logger.info("Bot started! Ready to receive forwarded messages")
            
            # Start polling and keep running
            await self.app.updater.start_polling()
            while True:
                await asyncio.sleep(1)
                
        except Exception as e:
            logger.error(f"Bot runtime error: {e}")
        finally:
            # Cleanup
            await self.app.stop()
            await self.app.shutdown()
            await self.client.disconnect()