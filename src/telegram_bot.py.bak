import asyncio
import os
import logging
import time
import json
import threading
import shutil
from concurrent.futures import ThreadPoolExecutor
from telethon import TelegramClient
from telethon.tl.types import MessageMediaPhoto, MessageMediaDocument
from telethon.errors import FloodWaitError, RPCError
from telegram import Update
from telegram.ext import Application, MessageHandler, filters, ContextTypes
from datetime import datetime

# è¨­å®šæ—¥èªŒ
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# æ¸›å°‘ç¬¬ä¸‰æ–¹åº«çš„è©³ç´°æ—¥èªŒ
logging.getLogger('httpx').setLevel(logging.WARNING)
# logging.getLogger('telegram').setLevel(logging.WARNING)
# logging.getLogger('telethon').setLevel(logging.WARNING)
logging.getLogger('telethon.client.updates').setLevel(logging.WARNING)
# logging.getLogger('urllib3').setLevel(logging.WARNING)
# logging.getLogger('asyncio').setLevel(logging.WARNING)

# Configuration will be passed from main.py or config module

class TelegramMediaBot:
    def __init__(self, api_id, api_hash, phone_number, bot_token):
        # Telegram Client (ç”¨æ–¼è¨ªå• API) - å„ªåŒ–é€£æ¥è¨­å®š
        self.client = TelegramClient(
            'bot_session', 
            api_id, 
            api_hash,
            connection_retries=3,
            retry_delay=1,
            auto_reconnect=True,
            timeout=30
        )
        
        # Save main event loop
        self.loop = asyncio.get_event_loop()
        
        # ä½µç™¼æ§åˆ¶
        self.max_concurrent_downloads = 5
        self.download_semaphore = asyncio.Semaphore(self.max_concurrent_downloads)
        
        # ç›£æ§è®Šé‡
        self.download_stats = {
            'total_files': 0,
            'completed_files': 0,
            'failed_files': 0,
            'total_size': 0,
            'downloaded_size': 0,
            'start_time': None
        }
        self.monitoring_active = False
        self.current_download_dir = None
        self.phone_number = phone_number
        self.bot_token = bot_token
        
        # Bot Application
        self.app = Application.builder().token(bot_token).build()
        
        # è¨­å®šè™•ç†å™¨
        self.app.add_handler(MessageHandler(filters.ALL, self.handle_message))
    
    async def start_client(self):
        """å•Ÿå‹• Telegram Client"""
        await self.client.start(phone=self.phone_number)
        logger.info("Telegram Client å·²å•Ÿå‹•")
    
    async def get_message_and_replies(self, chat_id, message_id):
        """ç²å–æŒ‡å®šè¨Šæ¯åŠå…¶æ‰€æœ‰å›è¦†"""
        try:
            logger.info(f"æ­£åœ¨ç²å– chat_id={chat_id}, message_id={message_id} çš„è¨Šæ¯")
            
            # ç²å–èŠå¤©å¯¦é«”
            try:
                chat = await self.client.get_entity(chat_id)
                logger.info(f"æˆåŠŸç²å–èŠå¤©å¯¦é«”: {chat.title if hasattr(chat, 'title') else chat}")
            except Exception as entity_error:
                logger.error(f"ç„¡æ³•ç²å–èŠå¤©å¯¦é«” {chat_id}: {entity_error}")
                return None, []
            
            # ç²å–åŸå§‹è¨Šæ¯
            try:
                original_message = await self.client.get_messages(chat, ids=message_id)
                if not original_message:
                    logger.warning(f"æœªæ‰¾åˆ°è¨Šæ¯ ID {message_id}")
                    return None, []
                logger.info(f"æˆåŠŸç²å–åŸå§‹è¨Šæ¯ ID {message_id}")
            except Exception as msg_error:
                logger.error(f"ç„¡æ³•ç²å–è¨Šæ¯ {message_id}: {msg_error}")
                return None, []
            
            # ç²å–æ‰€æœ‰å›è¦† - ä½¿ç”¨æ›´å®‰å…¨çš„æ–¹æ³•
            replies = []
            try:
                async for reply in self.client.iter_messages(chat, reply_to=message_id):
                    replies.append(reply)
                logger.info(f"æˆåŠŸç²å– {len(replies)} å‰‡å›è¦†")
            except Exception as reply_error:
                logger.warning(f"ç²å–å›è¦†æ™‚å‡ºéŒ¯ï¼Œä½†æœƒç¹¼çºŒè™•ç†åŸè¨Šæ¯: {reply_error}")
                # å³ä½¿ç²å–å›è¦†å¤±æ•—ï¼Œä¹Ÿè¿”å›åŸè¨Šæ¯
            
            logger.info(f"æ‰¾åˆ°åŸè¨Šæ¯å’Œ {len(replies)} å‰‡å›è¦†")
            return original_message, replies
            
        except RPCError as rpc_error:
            logger.error(f"Telegram API éŒ¯èª¤: {rpc_error}")
            return None, []
        except Exception as e:
            logger.error(f"ç²å–è¨Šæ¯æ™‚ç™¼ç”Ÿæœªé æœŸéŒ¯èª¤: {e}")
            return None, []
    
    async def download_media_with_retry(self, message, file_path, max_retries=3):
        """ä¸‹è¼‰åª’é«”æ–‡ä»¶ï¼ŒåŒ…å«é‡è©¦æ©Ÿåˆ¶å’Œé€²åº¦è¿½è¹¤"""
        async with self.download_semaphore:  # æ§åˆ¶ä½µç™¼æ•¸é‡
            for attempt in range(max_retries):
                try:
                    # åˆå§‹åŒ–é€²åº¦çµ±è¨ˆ
                    if hasattr(self, 'download_stats'):
                        self.download_stats['start_time'] = time.time()
                        self.download_stats['_last_progress'] = 0  # ç”¨æ–¼è¿½è¹¤é€²åº¦å·®
                        
                    # ä½¿ç”¨é€²åº¦å›èª¿ä¾†è¿½è¹¤ä¸‹è¼‰é€²åº¦
                    def progress_callback(current, total):
                        if hasattr(self, 'download_stats'):
                            # æ›´æ–°å·²ä¸‹è¼‰å¤§å°ï¼ˆç²—ç•¥ä¼°ç®—ï¼‰
                            downloaded = current - self.download_stats.get('_last_progress', 0)
                            self.download_stats['downloaded_size'] += max(downloaded, 0)
                            self.download_stats['_last_progress'] = current
                    
                    await self.client.download_media(
                        message, 
                        file_path,
                        progress_callback=progress_callback
                    )
                    
                    # æ›´æ–°çµ±è¨ˆ
                    if os.path.exists(file_path):
                        file_size = os.path.getsize(file_path)
                        # self.download_stats['downloaded_size'] += file_size
                        self.download_stats['completed_files'] += 1
                    
                    return True
                    
                except (ConnectionError, OSError, asyncio.TimeoutError, RPCError) as e:
                    if attempt == max_retries - 1:
                        logger.error(f"ä¸‹è¼‰å¤±æ•—ï¼Œå·²å˜—è©¦ {max_retries} æ¬¡: {e}")
                        self.download_stats['failed_files'] += 1
                        return False
                    
                    wait_time = (2 ** attempt) + 1  # æŒ‡æ•¸é€€é¿ï¼š2, 3, 5 ç§’
                    logger.warning(f"ä¸‹è¼‰å¤±æ•— (å˜—è©¦ {attempt + 1}/{max_retries})ï¼Œ{wait_time} ç§’å¾Œé‡è©¦: {e}")
                    await asyncio.sleep(wait_time)
                    
                except FloodWaitError as e:
                    logger.warning(f"è§¸ç™¼é™æµï¼Œç­‰å¾… {e.seconds} ç§’")
                    await asyncio.sleep(e.seconds)
                    
                except Exception as e:
                    logger.error(f"ä¸‹è¼‰æ™‚ç™¼ç”ŸæœªçŸ¥éŒ¯èª¤: {e}")
                    self.download_stats['failed_files'] += 1
                    return False
        
        return False

    def start_monitoring_thread(self, download_dir, processing_msg):
        """å•Ÿå‹•ç›£æ§ç·šç¨‹"""
        self.current_download_dir = download_dir
        self.monitoring_active = True
        
        def monitor_downloads():
            """ç›£æ§ä¸‹è¼‰é€²åº¦å’Œç£ç¢Ÿç©ºé–“"""
            last_update = time.time()
            
            while self.monitoring_active:
                try:
                    current_time = time.time()
                    
                    # æ¯5ç§’æ›´æ–°ä¸€æ¬¡
                    if current_time - last_update >= 5:
                        # ç²å–ç£ç¢Ÿç©ºé–“è³‡è¨Š
                        if self.current_download_dir and os.path.exists(self.current_download_dir):
                            total, used, free = shutil.disk_usage(self.current_download_dir)
                            free_gb = free / (1024**3)
                            
                            # è¨ˆç®—ä¸‹è¼‰é€Ÿåº¦
                            elapsed = current_time - (self.download_stats.get('start_time', current_time))
                            if elapsed > 0:
                                speed_mbps = (self.download_stats['downloaded_size'] / (1024**2)) / elapsed
                            else:
                                speed_mbps = 0
                            
                            # è¨ˆç®—ä¸‹è¼‰é€²åº¦ç™¾åˆ†æ¯”
                            if self.download_stats['total_size'] > 0:
                                progress_percent = (self.download_stats['downloaded_size'] / self.download_stats['total_size']) * 100
                            else:
                                progress_percent = 0
                            
                            # æ§‹å»ºç‹€æ…‹è¨Šæ¯
                            status_msg = (
                                f"â¬‡ï¸ å‚™ä»½é€²è¡Œä¸­...\n"
                                f"å·²å®Œæˆ: {self.download_stats['completed_files']}/{self.download_stats['total_files']} å€‹æ–‡ä»¶\n"
                                f"å¤±æ•—: {self.download_stats['failed_files']} å€‹\n"
                                f"é€²åº¦: {self.download_stats['downloaded_size']/(1024**2):.1f}MB / {self.download_stats['total_size']/(1024**2):.1f}MB ({progress_percent:.1f}%)\n"
                                f"é€Ÿåº¦: {speed_mbps:.1f}MB/s\n"
                                f"å‰©é¤˜ç©ºé–“: {free_gb:.1f}GB"
                            )
                            
                            # ç•°æ­¥æ›´æ–°æ¶ˆæ¯
                            asyncio.run_coroutine_threadsafe(
                                self.safe_update_message(processing_msg, status_msg),
                                self.loop
                            )
                            
                            # è¨˜éŒ„è©³ç´°æ—¥èªŒ
                            logger.info(
                                f"ä¸‹è¼‰ç‹€æ…‹ - å®Œæˆ: {self.download_stats['completed_files']}, "
                                f"å¤±æ•—: {self.download_stats['failed_files']}, "
                                f"é€Ÿåº¦: {speed_mbps:.1f}MB/s, "
                                f"å‰©é¤˜ç©ºé–“: {free_gb:.1f}GB"
                            )
                            
                            last_update = current_time
                    
                    time.sleep(1)  # æ¯ç§’æª¢æŸ¥ä¸€æ¬¡
                    
                except Exception as e:
                    logger.error(f"ç›£æ§ç·šç¨‹éŒ¯èª¤: {e}")
                    time.sleep(5)
        
        # åœ¨å¾Œå°ç·šç¨‹ä¸­é‹è¡Œç›£æ§
        monitor_thread = threading.Thread(target=monitor_downloads, daemon=True)
        monitor_thread.start()
        logger.info("ç›£æ§ç·šç¨‹å·²å•Ÿå‹•")

    async def safe_update_message(self, processing_msg, text):
        """å®‰å…¨åœ°æ›´æ–°æ¶ˆæ¯ï¼Œé¿å…é˜»å¡"""
        try:
            await processing_msg.edit_text(text)
        except Exception as e:
            # å¿½ç•¥æ¶ˆæ¯æ›´æ–°éŒ¯èª¤ï¼Œä¸å½±éŸ¿ä¸‹è¼‰é€²ç¨‹
            logger.debug(f"æ¶ˆæ¯æ›´æ–°å¤±æ•—: {e}")

    def stop_monitoring(self):
        """åœæ­¢ç›£æ§ç·šç¨‹"""
        self.monitoring_active = False
        logger.info("ç›£æ§ç·šç¨‹å·²åœæ­¢")

    async def get_media_size(self, message):
        """ç²å–åª’é«”æ–‡ä»¶å¤§å°"""
        try:
            if not message.media:
                return 0
            
            if isinstance(message.media, MessageMediaPhoto):
                # ç…§ç‰‡å¤§å°é€šå¸¸è¼ƒå°ï¼Œä½¿ç”¨é ä¼°å€¼
                return message.media.photo.sizes[-1].size if hasattr(message.media.photo, 'sizes') else 500000  # é ä¼°500KB
            
            elif isinstance(message.media, MessageMediaDocument):
                return message.media.document.size
                
        except Exception as e:
            logger.debug(f"ç²å–åª’é«”å¤§å°æ™‚å‡ºéŒ¯: {e}")
            return 0
        
        return 0

    async def download_multiple_messages_concurrent(self, messages, download_dir):
        """ä¸¦ç™¼ä¸‹è¼‰å¤šå€‹æ¶ˆæ¯çš„åª’é«”æ–‡ä»¶"""
        if not messages:
            return []
        
        # çµ±è¨ˆç¸½æ–‡ä»¶æ•¸å’Œç¸½å¤§å°
        total_media_count = sum(1 for msg in messages if msg.media)
        self.download_stats['total_files'] = total_media_count
        
        # è¨ˆç®—ç¸½æ–‡ä»¶å¤§å°
        total_size = 0
        for message in messages:
            if message.media:
                size = await self.get_media_size(message)
                total_size += size
        
        self.download_stats['total_size'] = total_size
        
        if total_media_count == 0:
            return []
        
        logger.info(f"é–‹å§‹ä¸¦ç™¼ä¸‹è¼‰ {total_media_count} å€‹åª’é«”æ–‡ä»¶ï¼Œç¸½å¤§å°: {total_size/(1024**2):.1f}MB")
        
        # å‰µå»ºä¸‹è¼‰ä»»å‹™
        download_tasks = []
        for message in messages:
            if message.media:
                task = self.download_media_from_message(message, download_dir)
                download_tasks.append(task)
        
        # ä¸¦ç™¼åŸ·è¡Œæ‰€æœ‰ä¸‹è¼‰ä»»å‹™
        try:
            results = await asyncio.gather(*download_tasks, return_exceptions=True)
            
            # åˆä½µçµæœ
            all_files = []
            for result in results:
                if isinstance(result, list):
                    all_files.extend(result)
                elif isinstance(result, Exception):
                    logger.error(f"ä¸‹è¼‰ä»»å‹™ç•°å¸¸: {result}")
                    self.download_stats['failed_files'] += 1
            
            return all_files
            
        except Exception as e:
            logger.error(f"ä¸‹è¼‰å‡ºéŒ¯: {e}")
            return []

    def save_progress(self, download_dir, progress_data):
        """ä¿å­˜ä¸‹è¼‰é€²åº¦"""
        progress_file = os.path.join(download_dir, '.download_progress.json')
        try:
            with open(progress_file, 'w', encoding='utf-8') as f:
                json.dump(progress_data, f, ensure_ascii=False, indent=2)
        except Exception as e:
            logger.warning(f"ç„¡æ³•ä¿å­˜é€²åº¦: {e}")

    def load_progress(self, download_dir):
        """è¼‰å…¥ä¸‹è¼‰é€²åº¦"""
        progress_file = os.path.join(download_dir, '.download_progress.json')
        try:
            if os.path.exists(progress_file):
                with open(progress_file, 'r', encoding='utf-8') as f:
                    return json.load(f)
        except Exception as e:
            logger.warning(f"ç„¡æ³•è¼‰å…¥é€²åº¦: {e}")
        return {"completed_files": [], "failed_files": []}

    async def download_media_from_message(self, message, download_dir):
        """å¾è¨Šæ¯ä¸­ä¸‹è¼‰åª’é«”æ–‡ä»¶"""
        if not message.media:
            return []
        
        try:
            os.makedirs(download_dir, exist_ok=True)
            downloaded_files = []
            
            # è™•ç†ç…§ç‰‡
            if isinstance(message.media, MessageMediaPhoto):
                file_name = f"photo_{message.id}_{message.date.strftime('%Y%m%d_%H%M%S')}.jpg"
                file_path = os.path.join(download_dir, file_name)
                
                if await self.download_media_with_retry(message, file_path):
                    downloaded_files.append(file_name)
                    logger.info(f"ä¸‹è¼‰ç…§ç‰‡: {file_name}")
                else:
                    logger.error(f"ç…§ç‰‡ä¸‹è¼‰å¤±æ•—: {file_name}")
                
            # è™•ç†æ–‡æª”ï¼ˆå½±ç‰‡ã€GIFç­‰ï¼‰
            elif isinstance(message.media, MessageMediaDocument):
                document = message.media.document
                
                # ç²å–æ–‡ä»¶å‰¯æª”å
                file_extension = ""
                original_name = ""
                
                for attr in document.attributes:
                    if hasattr(attr, 'file_name') and attr.file_name:
                        original_name = attr.file_name
                        file_extension = os.path.splitext(attr.file_name)[1]
                        break
                
                # å¦‚æœæ²’æœ‰å‰¯æª”åï¼Œæ ¹æ“š MIME é¡å‹æ¨æ–·
                if not file_extension:
                    mime_type = document.mime_type
                    if mime_type.startswith('video/'):
                        file_extension = '.mp4'
                    elif mime_type.startswith('image/'):
                        file_extension = '.gif' if 'gif' in mime_type else '.jpg'
                    elif mime_type.startswith('audio/'):
                        file_extension = '.mp3'
                    else:
                        file_extension = '.bin'
                
                # ä½¿ç”¨åŸæª”åæˆ–ç”Ÿæˆæ–°æª”å
                if original_name:
                    file_name = f"{message.id}_{original_name}"
                else:
                    file_name = f"document_{message.id}_{message.date.strftime('%Y%m%d_%H%M%S')}{file_extension}"
                
                file_path = os.path.join(download_dir, file_name)
                
                if await self.download_media_with_retry(message, file_path):
                    downloaded_files.append(file_name)
                    logger.info(f"ä¸‹è¼‰æ–‡æª”: {file_name}")
                else:
                    logger.error(f"æ–‡æª”ä¸‹è¼‰å¤±æ•—: {file_name}")
            
            return downloaded_files
            
        except Exception as e:
            logger.error(f"ä¸‹è¼‰åª’é«”æ™‚å‡ºéŒ¯: {e}")
            return []
    
    
    async def handle_message(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """è™•ç†æ”¶åˆ°çš„è¨Šæ¯"""
        message = update.message
        
        # æª¢æŸ¥æ˜¯å¦ç‚ºè½‰ç™¼è¨Šæ¯
        if not message.forward_origin:
            await message.reply_text(
                "è«‹è½‰ç™¼ä¸€å‰‡è¨Šæ¯çµ¦æˆ‘ï¼Œæˆ‘æœƒå‚™ä»½è©²è¨Šæ¯åŠå…¶æ‰€æœ‰å›è¦†ä¸­çš„åª’é«”æ–‡ä»¶åˆ°ä¼ºæœå™¨ï¼\n\n"
                "æ”¯æ´çš„åª’é«”é¡å‹ï¼šç…§ç‰‡ã€å½±ç‰‡ã€GIFã€éŸ³è¨Šç­‰"
            )
            return
        
        # ç™¼é€è™•ç†ä¸­è¨Šæ¯
        processing_msg = await message.reply_text("ğŸ”„ æ­£åœ¨å‚™ä»½ä¸­ï¼Œè«‹ç¨å€™...")
        
        try:
            # æå–åŸè¨Šæ¯è³‡è¨Š
            from telegram import MessageOriginChannel, MessageOriginUser, MessageOriginHiddenUser, MessageOriginChat
            
            if isinstance(message.forward_origin, MessageOriginChannel):
                # ä¾†è‡ªé »é“
                chat_id = message.forward_origin.chat.id
                original_message_id = message.forward_origin.message_id
                chat_name = message.forward_origin.chat.title or message.forward_origin.chat.username
            elif isinstance(message.forward_origin, MessageOriginChat):
                # ä¾†è‡ªç¾¤çµ„
                chat_id = message.forward_origin.sender_chat.id
                original_message_id = message.forward_origin.message_id
                chat_name = message.forward_origin.sender_chat.title or message.forward_origin.sender_chat.username
            else:
                # ä¾†è‡ªç§äººèŠå¤©æˆ–éš±è—ç”¨æˆ¶
                await processing_msg.edit_text("âŒ æš«ä¸æ”¯æ´ä¾†è‡ªç§äººèŠå¤©æˆ–éš±è—ç”¨æˆ¶çš„è½‰ç™¼è¨Šæ¯")
                return
            
            await processing_msg.edit_text(f"ğŸ“¡ æ­£åœ¨ç²å–ä¾†è‡ª {chat_name} çš„è¨Šæ¯...")
            
            # ç²å–åŸè¨Šæ¯å’Œå›è¦†
            original_message, replies = await self.get_message_and_replies(chat_id, original_message_id)
            
            if not original_message:
                error_msg = (
                    "âŒ ç„¡æ³•ç²å–åŸè¨Šæ¯\n\n"
                    "å¯èƒ½çš„åŸå› ï¼š\n"
                    "â€¢ Bot æ²’æœ‰æ¬Šé™è¨ªå•è©²é »é“/ç¾¤çµ„\n"
                    "â€¢ è¨Šæ¯å·²è¢«åˆªé™¤\n"
                    "â€¢ è¨Šæ¯ ID ç„¡æ•ˆ\n\n"
                    "è«‹ç¢ºèª Bot æ˜¯è©²é »é“/ç¾¤çµ„çš„æˆå“¡"
                )
                await processing_msg.edit_text(error_msg)
                return
            
            # å‰µå»ºä¸‹è¼‰ç›®éŒ„
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            download_dir = os.path.join('downloads', f"message_{original_message_id}_{timestamp}")
            os.makedirs(download_dir, exist_ok=True)
            
            # åˆå§‹åŒ–ä¸‹è¼‰çµ±è¨ˆ
            self.download_stats = {
                'total_files': 0,
                'completed_files': 0,
                'failed_files': 0,
                'total_size': 0,
                'downloaded_size': 0,
                'start_time': time.time()
            }
            
            # å•Ÿå‹•ç›£æ§ç·šç¨‹
            self.start_monitoring_thread(download_dir, processing_msg)
            
            try:
                await processing_msg.edit_text("ğŸ“Š æ­£åœ¨åˆ†æåª’é«”æ–‡ä»¶...")
                
                # æº–å‚™æ‰€æœ‰éœ€è¦ä¸‹è¼‰çš„æ¶ˆæ¯
                messages_to_download = []
                if original_message.media:
                    messages_to_download.append(original_message)
                
                for reply in replies:
                    if reply.media:
                        messages_to_download.append(reply)
                
                if not messages_to_download:
                    await processing_msg.edit_text("â„¹ï¸ è©²è¨Šæ¯åŠå…¶å›è¦†ä¸­æ²’æœ‰æ‰¾åˆ°ä»»ä½•åª’é«”æ–‡ä»¶")
                    return
                
                # è¨ˆç®—ç¸½æ–‡ä»¶å¤§å°ä»¥é¡¯ç¤ºåœ¨åˆå§‹è¨Šæ¯ä¸­
                total_size_mb = self.download_stats['total_size'] / (1024**2)
                await processing_msg.edit_text(f"ğŸš€ é–‹å§‹ä¸‹è¼‰ {len(messages_to_download)} å€‹åª’é«”æ–‡ä»¶ï¼Œç¸½å¤§å°: {total_size_mb:.1f}MB...")
                
                # ä½¿ç”¨ä¸¦ç™¼ä¸‹è¼‰
                all_downloaded_files = await self.download_multiple_messages_concurrent(
                    messages_to_download, download_dir
                )
                
            finally:
                # åœæ­¢ç›£æ§ç·šç¨‹
                self.stop_monitoring()
            
            # è¨ˆç®—ä¸‹è¼‰æ™‚é–“å’Œé€Ÿåº¦
            elapsed_time = time.time() - self.download_stats['start_time']
            avg_speed = (self.download_stats['downloaded_size'] / (1024**2)) / max(elapsed_time, 1)
            
            # ç²å–æœ€çµ‚ç£ç¢Ÿç©ºé–“
            if os.path.exists(download_dir):
                total, used, free = shutil.disk_usage(download_dir)
                free_gb = free / (1024**3)
            else:
                free_gb = 0
            
            # å»ºç«‹çµæœè¨Šæ¯
            result_msg = f"âœ… ä¸‹è¼‰å®Œæˆï¼\n"
            result_msg += f"åŸè¨Šæ¯ ID: {original_message_id}\n"
            result_msg += f"ä¾†æº: {chat_name}\n"
            result_msg += f"æˆåŠŸä¸‹è¼‰: {self.download_stats['completed_files']} å€‹åª’é«”æ–‡ä»¶\n"
            
            if self.download_stats['failed_files'] > 0:
                result_msg += f"å¤±æ•—: {self.download_stats['failed_files']} å€‹æ–‡ä»¶\n"
            
            # é¡¯ç¤ºä¸‹è¼‰å¤§å°å’Œé æœŸå¤§å°çš„å°æ¯”
            if self.download_stats['total_size'] > 0:
                completion_rate = (self.download_stats['downloaded_size'] / self.download_stats['total_size']) * 100
                result_msg += f"ä¸‹è¼‰å¤§å°: {self.download_stats['downloaded_size']/(1024**2):.1f}MB / {self.download_stats['total_size']/(1024**2):.1f}MB ({completion_rate:.1f}%)\n"
            else:
                result_msg += f"ä¸‹è¼‰å¤§å°: {self.download_stats['downloaded_size']/(1024**2):.1f}MB\n"
            
            result_msg += f"å¹³å‡é€Ÿåº¦: {avg_speed:.1f}MB/s\n"
            result_msg += f"è€—æ™‚: {elapsed_time:.1f}ç§’\n"
            result_msg += f"å‰©é¤˜ç©ºé–“: {free_gb:.1f}GB\n"
            result_msg += f"å„²å­˜ä½ç½®: {download_dir}"
            
            await processing_msg.edit_text(result_msg)
            
            # è¨˜éŒ„å®Œæˆæ—¥èªŒ
            logger.info(
                f"ä¸‹è¼‰å®Œæˆ - æˆåŠŸ: {self.download_stats['completed_files']}, "
                f"å¤±æ•—: {self.download_stats['failed_files']}, "
                f"ç¸½å¤§å°: {self.download_stats['downloaded_size']/(1024**2):.1f}MB, "
                f"é€Ÿåº¦: {avg_speed:.1f}MB/s"
            )
            
        except Exception as e:
            logger.error(f"è™•ç†è¨Šæ¯æ™‚å‡ºéŒ¯: {e}")
            await processing_msg.edit_text(f"âŒ è™•ç†æ™‚å‡ºéŒ¯: {str(e)}")
    
    async def run(self):
        """å•Ÿå‹• Bot"""
        try:
            # å•Ÿå‹• Telegram Client
            await self.start_client()
            
            # å•Ÿå‹• Bot
            logger.info("æ­£åœ¨å•Ÿå‹• Telegram Bot...")
            await self.app.initialize()
            await self.app.start()
            
            logger.info("Bot å·²å•Ÿå‹•ï¼å¯ä»¥é–‹å§‹è½‰ç™¼è¨Šæ¯äº†")
            
            # ä¿æŒé‹è¡Œ
            await self.app.updater.start_polling()
            
            # ç­‰å¾…ç›´åˆ°è¢«åœæ­¢
            while True:
                await asyncio.sleep(1)
                
        except Exception as e:
            logger.error(f"Bot é‹è¡Œå‡ºéŒ¯: {e}")
        finally:
            # æ¸…ç†
            await self.app.stop()
            await self.app.shutdown()
            await self.client.disconnect()

# å‰µå»º Bot å¯¦ä¾‹ä¸¦é‹è¡Œ
async def main():
    bot = TelegramMediaBot(API_ID, API_HASH, PHONE_NUMBER, BOT_TOKEN)
    await bot.run()

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        logger.info("Bot å·²åœæ­¢")
    except Exception as e:
        logger.error(f"ç¨‹å¼å‡ºéŒ¯: {e}")